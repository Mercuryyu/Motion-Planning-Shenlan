function [path,OPEN] = A_star_search(map,MAX_X,MAX_Y,hn_opt)
%%
%This part is about map/obstacle/and other settings
    %pre-process the grid map, add offset
    size_map = size(map,1);
    Y_offset = 0;
    X_offset = 0;
    
    %Define the 2D grid map array.
    %Obstacle=-1, Target = 0, Start=1
    MAP=2*(ones(MAX_X,MAX_Y));
    
    %Initialize MAP with location of the target
    xval=floor(map(size_map, 1)) + X_offset;
    yval=floor(map(size_map, 2)) + Y_offset;
    xTarget=xval;
    yTarget=yval;
    MAP(xval,yval)=0;
    
    %Initialize MAP with location of the obstacle
    for i = 2: size_map-1
        xval=floor(map(i, 1)) + X_offset;
        yval=floor(map(i, 2)) + Y_offset;
        MAP(xval,yval)=-1;
    end 
    
    %Initialize MAP with location of the start point
    xval=floor(map(1, 1)) + X_offset;
    yval=floor(map(1, 2)) + Y_offset;
    xStart=xval;
    yStart=yval;
    MAP(xval,yval)=1;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %LISTS USED FOR ALGORITHM
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %OPEN LIST STRUCTURE
    %--------------------------------------------------------------------------
    %IS ON LIST 1/0 |X val |Y val |Parent X val |Parent Y val |h(n) |g(n)|f(n)|
    %--------------------------------------------------------------------------
    OPEN=[];
    %CLOSED LIST STRUCTURE
    %--------------
    %X val | Y val |
    %--------------
    % CLOSED=zeros(MAX_VAL,2);
    CLOSED=[];

    %Put all obstacles on the Closed list
    k=1;%Dummy counter
    for i=1:MAX_X
        for j=1:MAX_Y
            if(MAP(i,j) == -1)
                CLOSED(k,1)=i;
                CLOSED(k,2)=j;
                k=k+1;
            end
        end
    end
    CLOSED_COUNT=size(CLOSED,1);
    %set the starting node as the first node
    xNode=xval;
    yNode=yval;
    OPEN_COUNT=1;
    hn=heuristic(xNode,yNode,xTarget,yTarget,hn_opt);
    
    path_cost=0;
    OPEN(OPEN_COUNT,:)=insert_open(xNode,yNode,xNode,yNode,hn,path_cost,hn);
    % OPEN(OPEN_COUNT,1)=0;
    % CLOSED_COUNT=CLOSED_COUNT+1;
    % CLOSED(CLOSED_COUNT,1)=xNode;
    % CLOSED(CLOSED_COUNT,2)=yNode;
    NoPath=1; 
    
%%
%This part is your homework
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% START ALGORITHM
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    while(1) %loop untill the open list is empty
        OPEN_COUNT = size(OPEN,1);
        % find node with lowest g(n) from the priority queue
        cur_index = min_fn(OPEN,OPEN_COUNT,xTarget,yTarget);
        if(cur_index==-1)  % openlist is empty 
            break;
        end
        % remove it from the priority queue
        OPEN(cur_index,1)=0;
        cur_xNode = OPEN(cur_index,2);
        cur_yNode = OPEN(cur_index,3);
        cur_gn = OPEN(cur_index,7);
        
        % mark the node as expanded
        CLOSED_COUNT=CLOSED_COUNT+1;
        CLOSED(CLOSED_COUNT,1)=cur_xNode;
        CLOSED(CLOSED_COUNT,2)=cur_yNode;
        
        % if the node "n" is the goal state, return true; break;
        if(cur_xNode==xTarget && cur_yNode==yTarget)
            NoPath = 0; 
            break;
        end

        % for all unexpanded neighbors m of node n
        m = expand_array(cur_xNode,cur_yNode,cur_gn,xTarget,yTarget,CLOSED,MAX_X,MAX_Y,hn_opt);
        % check if they are already in openlist
        % yes: check if needs update
        % no: directly add them to openlist
        for i = 1:size(m,1)
            nb_xNode = m(i,1);
            nb_yNode = m(i,2);
            nb_hn = m(i,3);
            nb_gn = m(i,4);
            nb_fn = m(i,5);
            nb_inlist = 0;
            OPEN_COUNT = size(OPEN,1);
            for j = 1:OPEN_COUNT
                if(nb_xNode==OPEN(j,2) && nb_yNode==OPEN(j,3))
                    nb_inlist = 1; % flag this neighbor is in openlist
                    pre_gn = OPEN(j,7); % get its gn
                    break;
                end
            end
            if(nb_inlist==1) 
                if(nb_gn<pre_gn) %if needs update
                    OPEN(j,:)=insert_open(nb_xNode,nb_yNode,cur_xNode,cur_yNode,nb_hn,nb_gn,nb_fn);
                end
            else % add node in open list
                OPEN(OPEN_COUNT+1,:)=insert_open(nb_xNode,nb_yNode,cur_xNode,cur_yNode,nb_hn,nb_gn,nb_fn);
            end
        end
     
    end %End of While Loop
%     % record number of visted nodes
%     for i = 1:size(OPEN,1)
%         if(OPEN(i,1)==0)
%             countVisited = countVisited+1;
%         end
%     end
    %Once algorithm has run The optimal path is generated by starting of at the
    %last node(if it is the target node) and then identifying its parent node
    %until it reaches the start node.This is the optimal path
    
    %
    %How to get the optimal path after A_star search?
    %please finish it
    
   path = [];
    if(NoPath==0) % optimal goal found
        i = 1;
        path_xNode = xTarget; 
        path_yNode = yTarget;
        % add Target node to th path
        path(i,1) = path_xNode;
        path(i,2) = path_yNode;
        while(path_xNode~=xStart || path_yNode~=yStart) % loop until find start node
            % find index of path node
            n_index = node_index(OPEN, path_xNode, path_yNode);
            % get new path node(its parent node)
            path_xNode = OPEN(n_index, 4);
            path_yNode = OPEN(n_index, 5);
            % add it in the path
            i = i+1;
            path(i,1) = path_xNode; 
            path(i,2) = path_yNode;
        end
        % reverse the path
        path = reverse(path, 1, i);
    end
end
